レイヤードアーキテクチャ

3層
Presentation（Route）
↓
Business（Service + Domain）
↓
Infrastructure（Repository）


4層（ドメインルールが多い時とか）
Presentation（Route）　HTTPを受け取り、Serviceを呼ぶ
↓
Application（Service）　ユースケースを実行、Domainを利用し、Repositoryを呼ぶ
↓
Domain（Entity）　エンティティ・ビジネスロジックの定義
↓
Infrastructure（Repository）　データ保存や外部技術の実装

post
4層で実装
サービスがリポジトリに依存（ドメインはインフラを知らない）

user
4層で実装
サービスがリポジトリに依存（ドメインはインフラを知らない）
カスタムエラーを作成



クリーン？オニオン？に近づけるには

Controller
↓
UseCase
↓
Entity
↓
Repository Interface
　　　↑
Repository Implementation
　　　↓
DB


Repository Interface　－　インターフェースのみ
Repository Implementation　－　インターフェースの実装
UseCaseは実際の実装は知らない
エンティティはどこにも依存しない

Repositoryの技術変更の際、
インタフェースなし → useCaseとimplementationを修正
インタフェースあり → implementationだけを修正
あと技術依存していないからテストとかしやすい


チャッピー

🧱 レイヤード = レイヤー構造

役割ごとに層を分ける設計

Presentation / Application / Infrastructure など

上の層が下の層に依存する（普通は一方向）

👉 「整理のための構造」


🧅 オニオン = ドメイン中心レイヤード

レイヤー構造を保ちつつ

Domainを中心に置く

依存は必ず内側へ向かう

Repositoryは抽象を内側に置く

👉 「ドメインを守るレイヤード」


🧼 クリーン = オニオンをより厳密にしたもの

オニオンと思想はほぼ同じ

UseCaseを明確に分離

Input/Output Portを使うこともある

依存逆転をより厳密に説明

👉 「依存逆転を徹底した設計」